use crate::db::DB;
use crate::prelude::FinanalizeError;
use crate::prelude::*;
use chrono::{DateTime, Utc};
use rust_decimal::prelude::FromPrimitive;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use serde_json;
use std::collections::VecDeque;
use surrealdb::sql::{Thing, Uuid};

// ----------- Wallet Struct --------------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallet {
    pub id: Thing,
    #[serde(
        serialize_with = "serialize_transactions",
        deserialize_with = "deserialize_transactions"
    )]
    pub transactions: VecDeque<WalletTransaction>,
}

impl Wallet {
    /// Creates a new wallet instance in SurrealDB (ID auto-generated by SurrealDB)
    pub async fn new() -> Result<Self> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        // Create a new wallet record in the DB, letting SurrealDB auto-generate the ID
        let wallet: Option<Wallet> = db
            .create("wallet")
            .content(Wallet {
                id: Thing::from((String::from("wallet"), Uuid::new_v4().to_string())),
                transactions: VecDeque::new(),
            })
            .await?;

        wallet.ok_or(FinanalizeError::DatabaseError(
            "Wallet creation failed".to_string(),
        ))
    }

    /// Calculates the wallet balance based on transactions.
    pub fn calculate_balance(&self) -> Decimal {
        self.transactions
            .iter()
            .fold(Decimal::ZERO, |acc, transaction| match transaction {
                WalletTransaction::Credit { amount, .. } => acc + amount,
                WalletTransaction::Report(bill) => acc - bill.total_cost,
            })
    }

    /// Adds credits to the wallet.
    pub fn add_credits(&mut self, amount: Decimal) {
        self.transactions.push_back(WalletTransaction::Credit {
            description: "Added credits".to_string(),
            amount,
        });
    }

    /// Uses tokens for a report. If the bill does not exist, a new one is created.
    pub async fn use_tokens_on_report(
        &mut self,
        wallet_id: &str,
        report_id: &str,
        tokens: i32,
        api_type: &str,
    ) -> crate::prelude::Result<Decimal> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        let cost_per_token = match api_type {
            "OpenAI" => Decimal::new(25, 1),
            "Anthropic" => Decimal::new(22, 1),
            "Google" => Decimal::new(20, 1),
            "Azure" => Decimal::new(18, 1),
            _ => Decimal::ZERO,
        };

        let total_cost = cost_per_token
            * Decimal::from_i32(tokens).ok_or(FinanalizeError::InvalidAmount(
                "Invalid token amount".to_string(),
            ))?;

        if self.calculate_balance() < total_cost {
            return Err(FinanalizeError::InsufficientFunds);
        }

        // Retrieve the existing report bill if any
        let existing_bill = Self::get_report_bill(report_id).await.ok();

        // If a bill exists, update it; otherwise, create a new one
        let report_bill = if let Some(mut bill) = existing_bill {
            bill.tokens_used += tokens;
            bill.total_cost += total_cost;
            bill
        } else {
            // Create a new ReportBill without the default, using a new Thing with a proper ID
            let report_bill = ReportBill {
                id: Thing::from((String::from("report_bill"), Uuid::new_v4().to_string())),
                report_id: report_id.to_string(),
                tokens_used: tokens,
                total_cost,
                api_type: api_type.to_string(),
                created_at: Utc::now(),
            };

            // Create the report bill in SurrealDB, SurrealDB will generate the ID
            let response: Option<ReportBill> = db
                .create("report_bill")
                .content(report_bill.clone())
                .await?;

            match response {
                Some(report_bill) => report_bill,
                None => {
                    return Err(FinanalizeError::DatabaseError(
                        "No report bill created".to_string(),
                    ));
                }
            }
        };

        let wallet_id = Thing::from(("wallet", wallet_id));
        let report_bill_id = report_bill.id.clone();
        // Relate the wallet to the report bill using SurrealDB-style query

        db.query("RELATE $wallet->has_spent->$report_bill")
            .bind(("wallet", wallet_id))
            .bind(("report_bill", report_bill_id))
            .await?;

        // After the report bill is created or updated
        self.transactions
            .push_back(WalletTransaction::Report(report_bill.clone()));

        // Return the total cost
        Ok(total_cost)
    }

    /// Retrieves a report bill using a report_id.
    pub async fn get_report_bill(report_id: &str) -> crate::prelude::Result<ReportBill> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        // Run the query and get the response
        let bill: ReportBill = db
            .select(("report_bill", report_id))
            .await?
            .ok_or(FinanalizeError::NotFound)?;
        Ok(bill)
    }

    /// Relates the wallet to a user.
    pub async fn relate_wallet_to_user(wallet_id: &str, user_id: &str) -> Result<()> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        let user_id = Thing::from(("user", user_id));
        let wallet_id = Thing::from(("wallet", wallet_id));

        db.query("RELATE $user->has_wallet->$wallet")
            .bind(("user", user_id))
            .bind(("wallet", wallet_id))
            .await?;

        Ok(())
    }

    /// Generates a wallet bill.
    pub fn generate_wallet_bill(&self) -> String {
        let mut bill_output = String::new();
        bill_output.push_str("---------------------\n");
        bill_output.push_str("Wallet Bill:\n");
        bill_output.push_str("---------------------\n");

        let mut total_spent = Decimal::ZERO;
        for transaction in &self.transactions {
            match transaction {
                WalletTransaction::Report(bill) => {
                    total_spent += bill.total_cost;
                    bill_output.push_str(&format!(
                        "{} Token Generation: {} tokens generated, cost: {:.2} credits, API: {}\n",
                        bill.api_type, bill.tokens_used, bill.total_cost, bill.api_type
                    ));
                }
                WalletTransaction::Credit { amount, .. } => {
                    bill_output
                        .push_str(&format!("Credit Addition: {:.2} credits added\n", amount));
                }
            }
        }
        bill_output.push_str("---------------------\n");
        let remaining = self.calculate_balance();
        bill_output.push_str(&format!("Total remaining credits: {:.2}\n", remaining));
        bill_output.push_str("---------------------\n");

        bill_output
    }
}

// ----------- Wallet Transactions ----------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WalletTransaction {
    Credit {
        description: String,
        amount: Decimal,
    },
    Report(ReportBill),
}

// ----------- ReportBill Struct ----------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportBill {
    pub id: Thing,
    pub report_id: String,
    pub tokens_used: i32,
    pub total_cost: Decimal,
    pub api_type: String,
    pub created_at: DateTime<Utc>,
}

fn serialize_transactions<S>(
    transactions: &VecDeque<WalletTransaction>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let vec: Vec<WalletTransaction> = transactions.iter().cloned().collect();
    vec.serialize(serializer)
}

fn deserialize_transactions<'de, D>(
    deserializer: D,
) -> std::result::Result<VecDeque<WalletTransaction>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let vec: Vec<WalletTransaction> = Vec::deserialize(deserializer)?;
    Ok(VecDeque::from(vec))
}

#[cfg(test)]
mod tests {
    use crate::db;

    use super::*;
    use rust_decimal::Decimal;
    use tokio;

    #[tokio::test]
    async fn test_wallet_creation() {
        let con = db::connect().await.unwrap();
        DB.set(con).unwrap();
        let wallet = Wallet::new().await.expect("Failed to create wallet");
        assert_eq!(wallet.calculate_balance(), Decimal::ZERO);
        assert!(
            !wallet.id.id.to_string().is_empty(),
            "Wallet ID should be generated by SurrealDB"
        );
    }

    #[tokio::test]
    async fn test_add_credits() {
        let con = db::connect().await.unwrap();
        DB.set(con).unwrap();
        let mut wallet = Wallet::new().await.expect("Failed to create wallet");
        assert_eq!(wallet.calculate_balance(), Decimal::ZERO);

        wallet.add_credits(Decimal::new(500, 0)); // Add 500 credits
        assert_eq!(wallet.calculate_balance(), Decimal::new(500, 0));
    }

    #[tokio::test]
    async fn test_use_tokens_on_report() {
        let con = db::connect().await.unwrap();
        DB.set(con).unwrap();
        let mut wallet = Wallet::new().await.expect("Failed to create wallet");
        wallet.add_credits(Decimal::new(500, 0)); // Add some credits for the test

        let wallet_id_str = wallet.id.to_string();

        // Use tokens for different reports
        let report_1 = wallet
            .use_tokens_on_report(&wallet_id_str, "report_1", 20, "OpenAI")
            .await
            .expect("Failed to use tokens on report");
        let report_2 = wallet
            .use_tokens_on_report(&wallet_id_str, "report_1", 30, "Anthropic")
            .await
            .expect("Failed to use tokens on report");
        let report_3 = wallet
            .use_tokens_on_report(&wallet_id_str, "report_2", 15, "Google")
            .await
            .expect("Failed to use tokens on report");

        // Calculate the expected balance after token usage
        let expected_balance = Decimal::new(500, 0) - report_1 - report_2 - report_3;
        assert_eq!(wallet.calculate_balance(), expected_balance);
    }

    #[tokio::test]
    async fn test_generate_wallet_bill() {
        let con = db::connect().await.unwrap();
        DB.set(con).unwrap();
        let mut wallet = Wallet::new().await.expect("Failed to create wallet");
        wallet.add_credits(Decimal::new(500, 0)); // Add some credits for the test

        let wallet_id_str = wallet.id.to_string();

        // Use tokens for reports
        wallet
            .use_tokens_on_report(&wallet_id_str, "report_1", 20, "OpenAI")
            .await
            .expect("Failed to use tokens on report");
        println!(
            "Wallet balance after OpenAI report: {}",
            wallet.calculate_balance()
        );

        wallet
            .use_tokens_on_report(&wallet_id_str, "report_1", 30, "Anthropic")
            .await
            .expect("Failed to use tokens on report");
        println!(
            "Wallet balance after Anthropic report: {}",
            wallet.calculate_balance()
        );

        wallet
            .use_tokens_on_report(&wallet_id_str, "report_2", 15, "Google")
            .await
            .expect("Failed to use tokens on report");
        println!(
            "Wallet balance after Google report: {}",
            wallet.calculate_balance()
        );

        // Generate the wallet bill
        let wallet_bill = wallet.generate_wallet_bill();
        println!("\nWallet Bill:\n{}", wallet_bill);

        // Assertions to verify if the bill is correctly formatted
        assert!(
            wallet_bill.contains("Token Generation"),
            "Bill should contain token generation information"
        );
        assert!(
            wallet_bill.contains("Total remaining credits"),
            "Bill should contain total remaining credits"
        );
    }
}
