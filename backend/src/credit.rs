use crate::api::ApiResponse;
use crate::db::{SurrealDb, DB};
use crate::models::SurrealDBUser;
use crate::prelude::FinanalizeError;
use crate::prelude::*;
use crate::workflow::{SDBWorkflowState, WorkflowState};
use actix_web::get;
use actix_web::post;
use actix_web::web::Data;
use actix_web::{web, HttpResponse, Responder};
use log::debug;
use rust_decimal::prelude::FromPrimitive;
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};
use std::collections::VecDeque;
use surrealdb::sql::{Thing, Uuid};

// ----------- Wallet Struct --------------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Wallet {
    pub id: Thing,
    #[serde(
        serialize_with = "serialize_transactions",
        deserialize_with = "deserialize_transactions"
    )]
    pub transactions: VecDeque<WalletTransaction>,
}

impl Wallet {
    /// Creates a new wallet instance in SurrealDB (ID auto-generated by SurrealDB)
    pub async fn new() -> Result<Self> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        // Create a new wallet record in the DB, letting SurrealDB auto-generate the ID
        let wallet: Option<Wallet> = db
            .create("wallet")
            .content(Wallet {
                id: Thing::from((String::from("wallet"), Uuid::new_v4().to_string())),
                transactions: VecDeque::new(),
            })
            .await?;

        wallet.ok_or(FinanalizeError::DatabaseError(
            "Wallet creation failed".to_string(),
        ))
    }

    /// Calculates the wallet balance based on transactions.
    pub fn calculate_balance(&self) -> Decimal {
        self.transactions
            .iter()
            .fold(Decimal::ZERO, |acc, transaction| match transaction {
                WalletTransaction::Credit { amount, .. } => acc + amount,
                WalletTransaction::Report(bill) => acc - bill.total_cost,
            })
    }

    /// Adds credits to the wallet.
    pub fn add_credits(&mut self, amount: Decimal) {
        self.transactions.push_back(WalletTransaction::Credit {
            description: "Added credits".to_string(),
            amount,
        });
    }

    /// Uses tokens for a report. If the bill does not exist, a new one is created.
    pub async fn use_tokens_on_report(
        &mut self,
        report_id: &str,
    ) -> crate::prelude::Result<Decimal> {
        let db = DB.get().unwrap();

        let sdb_report: SDBWorkflowState = db
            .select(("workflow_state", report_id))
            .await?
            .ok_or(FinanalizeError::NotFound)?;

        let report: WorkflowState = sdb_report.into();

        let mut total = Decimal::ZERO;
        for gr in report.state.generation_results {
            let api = gr.api.clone();
            total += api.cost(gr.clone());
        }

        if self.calculate_balance() < total {
            return Err(FinanalizeError::InsufficientFunds);
        }

        // After the report bill is created or updated
        self.transactions
            .push_back(WalletTransaction::Report(ReportBill {
                report_id: report_id.to_string(),
                total_cost: total,
            }));

        // Return the total cost
        Ok(total)
    }

    /// Retrieves a report bill using a report_id.
    pub async fn get_report_bill(self, report_id: &str) -> crate::prelude::Result<ReportBill> {
        self.transactions
            .iter()
            .filter_map(|transaction| match transaction {
                WalletTransaction::Report(bill) if bill.report_id == report_id => {
                    Some(bill.clone())
                }
                _ => None,
            })
            .next()
            .ok_or(FinanalizeError::NotFound)
    }

    /// Relates the wallet to a user.
    pub async fn relate_wallet_to_user(wallet_id: &str, user_id: &str) -> Result<()> {
        let db = DB.get().ok_or(FinanalizeError::DatabaseError(
            "Database not initialized".to_string(),
        ))?;

        let user_id = Thing::from(("user", user_id));
        let wallet_id = Thing::from(("wallet", wallet_id));

        db.query("RELATE $user->has_wallet->$wallet")
            .bind(("user", user_id))
            .bind(("wallet", wallet_id))
            .await?;

        Ok(())
    }
}

// ----------- Wallet Transactions ----------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum WalletTransaction {
    Credit {
        description: String,
        amount: Decimal,
    },
    Report(ReportBill),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ReportBill {
    pub report_id: String,
    pub total_cost: Decimal,
}

impl From<SDBReportBill> for ReportBill {
    fn from(sdb_report_bill: SDBReportBill) -> Self {
        ReportBill {
            report_id: sdb_report_bill.report_id,
            total_cost: sdb_report_bill.total_cost,
        }
    }
}

// ----------- ReportBill Struct ----------
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SDBReportBill {
    pub id: Thing,
    pub report_id: String,
    pub total_cost: Decimal,
}

fn serialize_transactions<S>(
    transactions: &VecDeque<WalletTransaction>,
    serializer: S,
) -> std::result::Result<S::Ok, S::Error>
where
    S: serde::Serializer,
{
    let vec: Vec<WalletTransaction> = transactions.iter().cloned().collect();
    vec.serialize(serializer)
}

fn deserialize_transactions<'de, D>(
    deserializer: D,
) -> std::result::Result<VecDeque<WalletTransaction>, D::Error>
where
    D: serde::Deserializer<'de>,
{
    let vec: Vec<WalletTransaction> = Vec::deserialize(deserializer)?;
    Ok(VecDeque::from(vec))
}

#[get("/wallet/balance")]
pub async fn get_wallet_balance(
    user: SurrealDBUser,
    db: Data<SurrealDb>,
) -> crate::prelude::Result<impl Responder> {
    // Probeer de wallet uit de database te halen
    let wallet: Option<Wallet> = db.select(("wallet", &user.id.id.to_string())).await?;

    let wallet = if let Some(wallet) = wallet {
        wallet
    } else {
        // Als de wallet niet bestaat, maak er dan een aan
        let new_wallet = Wallet {
            id: Thing::from(("wallet", user.id.id.to_string().as_str())),
            transactions: VecDeque::new(),
        };

        // Sla de nieuwe wallet op in de database
        let created_wallet: Option<Wallet> = db
            .create("wallet") // Specify the resource type
            .content(Some(new_wallet)) // Wrap the wallet in Some()
            .await?;

        created_wallet.ok_or(FinanalizeError::DatabaseError(
            "Failed to create wallet".to_string(),
        ))?
    };

    // Bereken de balans en geef deze terug
    let balance = wallet.calculate_balance();
    Ok(ApiResponse::new(balance))
}

#[get("/wallet/transactions")]
pub async fn get_wallet_transactions(
    user: SurrealDBUser,
    db: Data<SurrealDb>,
) -> crate::prelude::Result<impl Responder> {
    // Try to fetch the wallet from the database
    let wallet: Option<Wallet> = db.select(("wallet", &user.id.id.to_string())).await?;

    let wallet = if let Some(wallet) = wallet {
        wallet
    } else {
        // If the wallet doesn't exist, create a new one
        let new_wallet = Wallet {
            id: Thing::from(("wallet", user.id.id.to_string().as_str())),
            transactions: VecDeque::new(),
        };

        // Save the new wallet to the database
        let created_wallet: Option<Wallet> = db
            .create("wallet") // Specify the resource type
            .content(Some(new_wallet)) // Wrap the wallet in Some()
            .await?;

        created_wallet.ok_or(FinanalizeError::DatabaseError(
            "Failed to create wallet".to_string(),
        ))?
    };

    // Return the transactions of the wallet
    let transactions = wallet.transactions; // Assuming `transactions` is stored as `VecDeque<Transaction>`

    Ok(ApiResponse::new(transactions))
}

#[derive(Deserialize)]
pub struct AddCreditsRequest {
    amount: f64, // Use f64 for compatibility with Decimal
}

#[post("/wallet/add_credits")]
pub async fn add_credits(
    user: SurrealDBUser,
    db: Data<SurrealDb>,
    body: web::Json<AddCreditsRequest>,
) -> crate::prelude::Result<impl Responder> {
    let wallet_id = user.id.id.to_string();

    // Fetch the wallet from the database
    let wallet: Option<Wallet> = db.select(("wallet", wallet_id.clone())).await?;

    let wallet = if let Some(mut wallet) = wallet {
        // Convert f64 to Decimal safely
        if let Some(decimal_amount) = Decimal::from_f64(body.amount) {
            wallet.add_credits(decimal_amount);
        } else {
            return Err(FinanalizeError::InvalidAmount(
                "Invalid decimal conversion".to_string(),
            ));
        }

        // Clone wallet to pass an owned value instead of borrowing
        let updated_wallet: Option<Wallet> = db
            .update(("wallet", wallet_id.clone()))
            .content(wallet.clone())
            .await?;

        // Ensure the wallet update is successful
        updated_wallet.ok_or(FinanalizeError::DatabaseError(
            "Failed to update wallet".to_string(),
        ))?
    } else {
        return Err(FinanalizeError::NotFound);
    };

    Ok(HttpResponse::Ok().json(ApiResponse::new(wallet.calculate_balance())))
}

#[post("/wallet/buy_report/{report_id}")]
pub async fn buy_report(
    user: SurrealDBUser,
    db: web::Data<SurrealDb>,
    report_id: web::Path<String>,
) -> crate::prelude::Result<HttpResponse> {
    // Explicit return type
    let wallet_id = user.id.id.to_string();

    // Fetch wallet from the database
    debug!("Fetching wallet with ID: {}", wallet_id);
    let wallet_opt: Option<Wallet> = db.select(("wallet", wallet_id.clone())).await?;
    debug!("Wallet fetched: {:?}", wallet_opt);
    let mut wallet = wallet_opt.ok_or(FinanalizeError::NotFound)?;

    // Process token usage
    debug!("Using tokens on report with ID: {}", report_id);
    let cost: Decimal = wallet.use_tokens_on_report(&report_id).await?;
    debug!("{} tokens used", cost);

    debug!("Updating wallet with ID: {}", wallet_id);
    let updated_wallet: Option<Wallet> = db
        .update(("wallet", &wallet_id))
        .content(wallet.clone())
        .await?
        .ok_or(FinanalizeError::DatabaseError(
            "Failed to update wallet".to_string(),
        ))?;
    debug!("Wallet updated: {:?}", updated_wallet);

    Ok(HttpResponse::Ok().json(ApiResponse::new(updated_wallet)))
}
